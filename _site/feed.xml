<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-06-17T02:07:49+05:30</updated><id>http://localhost:4000/feed.xml</id><title type="html">Varsha Kulkarni</title><subtitle>Errs Unravelled</subtitle><entry><title type="html">How Joda Date library helped with every Date utilities, when we still had to support &amp;lt; Java 8</title><link href="http://localhost:4000/2022/05/22/Joda-lib.html" rel="alternate" type="text/html" title="How Joda Date library helped with every Date utilities, when we still had to support &amp;lt; Java 8" /><published>2022-05-22T00:00:00+05:30</published><updated>2022-05-22T00:00:00+05:30</updated><id>http://localhost:4000/2022/05/22/Joda-lib</id><content type="html" xml:base="http://localhost:4000/2022/05/22/Joda-lib.html">&lt;p&gt;Why Joda?&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://www.joda.org/joda-time/&quot;&gt;Joda-Time&lt;/a&gt; provides a quality replacement for the Java date and time classes.
The standard date and time classes prior to Java SE 8 are poor. By tackling this problem head-on, Joda-Time became the de facto standard date and time library for Java prior to Java SE 8.
From Java SE 8 onwards, users are asked to migrate to java.time (JSR-310).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Our project minSdk is set to 23 (Android 6/7)which continue to use older Java APIs.
Joda solves the problem of providing one set of APIs which can be used across all OS versions.&lt;/p&gt;

&lt;p&gt;Add the dependency&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;implementation 'net.danlew:android.joda:2.10.14'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Get date in the time zone&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val zone: DateTimeZone = DateTimeZone.forID(timezoneId)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;From Unix to human readable date at given timezone.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val zone: DateTimeZone = DateTimeZone.forID(timezoneId)
return DateTime(receivedTime * 1000L, zone)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Manipulate current time to trigger an alarm&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var triggerTime = date.plusHours(notificationCount).plusMinutes(totalDelay).withSecondOfMinute(0).withMillisOfSecond(0)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If device is in different time zone, convert to device time zone&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var deviceTime = triggerTime.withZone(DateTimeZone.getDefault())	
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Convert the device time to Calender object to pass it to AlarmManager&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val time = deviceTime.toGregorianCalendar()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Use this time to pass it to Alarm methods&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;alarmManager.setAlarmClock(
AlarmManager.AlarmClockInfo(time, pendingIntent),
pendingIntent)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;For Unit testing:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;testCompile 'joda-time:joda-time:2.10.14'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="Android" /><category term="Java8" /><category term="Date" /><category term="Joda" /><summary type="html">Why Joda? Joda-Time provides a quality replacement for the Java date and time classes. The standard date and time classes prior to Java SE 8 are poor. By tackling this problem head-on, Joda-Time became the de facto standard date and time library for Java prior to Java SE 8. From Java SE 8 onwards, users are asked to migrate to java.time (JSR-310). Our project minSdk is set to 23 (Android 6/7)which continue to use older Java APIs. Joda solves the problem of providing one set of APIs which can be used across all OS versions. Add the dependency implementation 'net.danlew:android.joda:2.10.14' Get date in the time zone val zone: DateTimeZone = DateTimeZone.forID(timezoneId) From Unix to human readable date at given timezone. val zone: DateTimeZone = DateTimeZone.forID(timezoneId) return DateTime(receivedTime * 1000L, zone) Manipulate current time to trigger an alarm var triggerTime = date.plusHours(notificationCount).plusMinutes(totalDelay).withSecondOfMinute(0).withMillisOfSecond(0) If device is in different time zone, convert to device time zone var deviceTime = triggerTime.withZone(DateTimeZone.getDefault()) Convert the device time to Calender object to pass it to AlarmManager val time = deviceTime.toGregorianCalendar() Use this time to pass it to Alarm methods alarmManager.setAlarmClock( AlarmManager.AlarmClockInfo(time, pendingIntent), pendingIntent) For Unit testing: testCompile 'joda-time:joda-time:2.10.14'</summary></entry><entry><title type="html">Bluetooth Permissions on Android 12</title><link href="http://localhost:4000/2022/05/04/bluetooth_permissions_on_android_12.html" rel="alternate" type="text/html" title="Bluetooth Permissions on Android 12" /><published>2022-05-04T00:00:00+05:30</published><updated>2022-05-04T00:00:00+05:30</updated><id>http://localhost:4000/2022/05/04/bluetooth_permissions_on_android_12</id><content type="html" xml:base="http://localhost:4000/2022/05/04/bluetooth_permissions_on_android_12.html">&lt;p&gt;Beginning with Android 12, new run-time permissions are added for accessing nearby Bluetooth devices. Without this permission any APIs related to Bluetooth devices access will result into Fatal Exception:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;java.lang.SecurityException
Need android.permission.BLUETOOTH_CONNECT permission ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;You can use permissions for Bluetooth as follows for targetSdk set to 31 and minSdk to 23&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &amp;lt;uses-permission
        android:name=&quot;android.permission.BLUETOOTH&quot;
        android:maxSdkVersion=&quot;30&quot; /&amp;gt;
    &amp;lt;uses-permission
        android:name=&quot;android.permission.BLUETOOTH_ADMIN&quot;
        android:maxSdkVersion=&quot;30&quot; /&amp;gt;
    &amp;lt;uses-permission android:name=&quot;android.permission.BLUETOOTH_CONNECT&quot; /&amp;gt;
    &amp;lt;uses-permission
        android:name=&quot;android.permission.BLUETOOTH_SCAN&quot;
        android:usesPermissionFlags=&quot;neverForLocation&quot;
        tools:targetApi=&quot;s&quot; /&amp;gt;
    &amp;lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&amp;gt;
    &amp;lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Please note that if your app makes the current device discoverable to other Bluetooth devices, that’s if the device which is running the app as master and advertising the data, then declare the BLUETOOTH_ADVERTISE permission.&lt;/p&gt;

&lt;p&gt;If you are looking for other Bluetooth devices, then declare BLUETOOTH_SCAN.&lt;/p&gt;

&lt;p&gt;If your app is doing any operations on Bluetooth devices like pairing, checking whether a peripheral is already connected, or connecting or communicate in any way, declare BLUETOOTH_CONNECT.&lt;/p&gt;

&lt;p&gt;Legacy Bluetooth permissions are required for older OS versions below Android 31.&lt;/p&gt;

&lt;p&gt;If in any way if your app is trying to derive user’s location using Scan results, then only request for Location permissions. else &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;usesPermissionFlags&lt;/code&gt; can be set to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;neverForLocation&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Then while requesting permissions, based on OS version, use the required run-time permission as follows:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  private String[] getRequiredPermissions() {
        int targetSdkVersion = getApplicationInfo().targetSdkVersion;
        if (Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.S &amp;amp;&amp;amp; targetSdkVersion &amp;gt;= Build.VERSION_CODES.S) {
            return new String[]{Manifest.permission.BLUETOOTH_SCAN, Manifest.permission.BLUETOOTH_CONNECT};
        } else if (Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.Q &amp;amp;&amp;amp; targetSdkVersion &amp;gt;= Build.VERSION_CODES.Q) {
            return new String[]{Manifest.permission.ACCESS_FINE_LOCATION};
        } else return new String[]{Manifest.permission.ACCESS_COARSE_LOCATION};
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="Android12" /><category term="targetSdk" /><category term="Bluetooth" /><category term="BLE" /><category term="run-time" /><category term="permissions" /><category term="location" /><category term="fine_location_permission" /><summary type="html">Beginning with Android 12, new run-time permissions are added for accessing nearby Bluetooth devices. Without this permission any APIs related to Bluetooth devices access will result into Fatal Exception:</summary></entry><entry><title type="html">Welcome!</title><link href="http://localhost:4000/welcome/2022/05/03/welcome.html" rel="alternate" type="text/html" title="Welcome!" /><published>2022-05-03T23:35:34+05:30</published><updated>2022-05-03T23:35:34+05:30</updated><id>http://localhost:4000/welcome/2022/05/03/welcome</id><content type="html" xml:base="http://localhost:4000/welcome/2022/05/03/welcome.html">&lt;p&gt;You will find here some debugging, some tips and tricks from my experience.&lt;/p&gt;</content><author><name></name></author><category term="welcome" /><summary type="html">You will find here some debugging, some tips and tricks from my experience.</summary></entry></feed>